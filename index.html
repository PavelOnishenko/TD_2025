<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimal Tower Defense</title>
  <style>
    body { margin: 0; background: #fff; }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="450"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const enemy = {
      x: 0,
      y: 365,
      w: 30,
      h: 30,
      speed: 50,
      hp: 3
    };

    const tower = {
      x: 400,
      y: 280,
      w: 40,
      h: 40,
      range: 120
    };

    const projectiles = [];
    const projectileSpeed = 200;
    const projectileRadius = 6;
    let lastShot = 0;

    let lastTime = 0;
    let gameOver = false;
    let win = false;

    function showEnd(text, color) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = color;
      ctx.font = '48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    }

    function update(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (gameOver) {
        showEnd(win ? 'YOU WIN' : 'GAME OVER', win ? 'green' : 'red');
        return;
      }

      enemy.x += enemy.speed * dt;

      if (enemy.x + enemy.w >= canvas.width) {
        gameOver = true;
        win = false;
      }

      const towerCenterX = tower.x + tower.w / 2;
      const towerCenterY = tower.y + tower.h / 2;
      const enemyCenterX = enemy.x + enemy.w / 2;
      const enemyCenterY = enemy.y + enemy.h / 2;
      const dx = enemyCenterX - towerCenterX;
      const dy = enemyCenterY - towerCenterY;
      const dist = Math.hypot(dx, dy);

      if (dist <= tower.range && timestamp - lastShot >= 1000) {
        const angle = Math.atan2(dy, dx);
        projectiles.push({
          x: towerCenterX,
          y: towerCenterY,
          vx: Math.cos(angle) * projectileSpeed,
          vy: Math.sin(angle) * projectileSpeed
        });
        lastShot = timestamp;
      }

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;

        if (
          p.x >= enemy.x &&
          p.x <= enemy.x + enemy.w &&
          p.y >= enemy.y &&
          p.y <= enemy.y + enemy.h
        ) {
          enemy.hp -= 1;
          projectiles.splice(i, 1);
          if (enemy.hp <= 0) {
            gameOver = true;
            win = true;
          }
          continue;
        }

        if (
          p.x < 0 ||
          p.x > canvas.width ||
          p.y < 0 ||
          p.y > canvas.height
        ) {
          projectiles.splice(i, 1);
        }
      }

      if (gameOver) {
        showEnd(win ? 'YOU WIN' : 'GAME OVER', win ? 'green' : 'red');
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // draw road
      ctx.fillStyle = '#888';
      ctx.fillRect(0, 380, canvas.width, 20);

      // draw tower range
      ctx.beginPath();
      ctx.arc(
        tower.x + tower.w / 2,
        tower.y + tower.h / 2,
        tower.range,
        0,
        Math.PI * 2
      );
      ctx.strokeStyle = 'rgba(0,0,255,0.3)';
      ctx.stroke();

      // draw tower
      ctx.fillStyle = 'blue';
      ctx.fillRect(tower.x, tower.y, tower.w, tower.h);

      // draw enemy
      ctx.fillStyle = 'red';
      ctx.fillRect(enemy.x, enemy.y, enemy.w, enemy.h);

      // draw projectiles
      ctx.fillStyle = 'black';
      projectiles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, projectileRadius, 0, Math.PI * 2);
        ctx.fill();
      });

      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
